[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Shiny apps",
    "section": "",
    "text": "Overview\nThis site contains the various shiny apps that I have made throughout the years.",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "index.html#source",
    "href": "index.html#source",
    "title": "Shiny apps",
    "section": "Source",
    "text": "Source\n\n\n\n\n\n\nQuarto blog publish details\n\n\n\nThis book was created using Quarto and published with Github Pages.\n\n\n\n\n\n\n\n\nGithub repository for code\n\n\n\nYou can find the code to reproduce this project at coltongearhart/shiny-apps.",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "greaves.html",
    "href": "greaves.html",
    "title": "Greaves",
    "section": "",
    "text": "Dashboard",
    "crumbs": [
      "Greaves"
    ]
  },
  {
    "objectID": "greaves.html#dashboard",
    "href": "greaves.html#dashboard",
    "title": "Greaves",
    "section": "",
    "text": "Demo - Tab 1\n\nDemo - Tab 2\n\nDemo - Tab 3\n\nApplication",
    "crumbs": [
      "Greaves"
    ]
  },
  {
    "objectID": "greaves.html#code",
    "href": "greaves.html#code",
    "title": "Greaves",
    "section": "Code",
    "text": "Code\nPre code\n\n### ----- READ ME ---- \n\n# This app demonstrates the properties and results of Gibbs sampling, a MCMC method\n# Once the number of parameters and number of iterations are initialized by the user,\n# it generates n random numbers from a dependent sampling scheme contruscted according to Gibbs sampling methods\n# The first tab demonstrates the properties / results of a Gibbs sampling algorithm\n# The first panel checks the last 100 sampled values via a scatterplot to see if we can consider the generated numbers as an independent samples\n# The second panel creates a histogram of the sampled values (minus the burn-in iterations) and compares it to the actual marginal densities\n# The third panel plots the density estimates obtained by averaging over the conditional densities; again it compares it to the known marginal density\n# The comparisons are made to demonstrate that Gibbs sampling results in samples from the desired distribution\n# The second tab is an application of Gibbs sampling, where there is no closed form solution for the distribution of interest\n# Once the iterations and parameters are initialized by the user, it will run the algorithm and output the estimated density and summary statistics\n\n# Packages -&gt; the following packages need to be installed in order to run this app\n# -&gt; tidyverse, magrittr, shiny, ggpubr, and actuar\n\n### ----- Load packages ---- \n\noptions(scipen = 999)\nlibrary(\"tidyverse\")\nlibrary(\"magrittr\")\nlibrary(\"shiny\")\nlibrary(\"ggpubr\")\n# for pareto function\nlibrary(\"actuar\")\n\n# help pages for reactive events and isolate\n# -&gt; reactive -&gt; https://shiny.rstudio.com/tutorial/written-tutorial/lesson6/\n# -&gt; isolate -&gt; https://shiny.rstudio.com/articles/isolation.html\n\n### ----- Load required items ---- \n\n# functions for demo\n\n# function to generate random data from conditional distributions\ngenerate_sample &lt;- function(n = 10000, alpha = 5, beta = 100, start_x = 5, start_lambda = 1.5, seed = 0) {\n  \n  # create matrix\n  data_sample &lt;- matrix(data = NA, nrow = n, ncol = 3, dimnames = list(NULL, c(\"iteration\", \"X\", \"lambda\")))\n  \n  # conditionally set random seed\n  if (seed &gt; 0) set.seed(seed)\n  \n  # initialize counter and starting values\n  i = 1\n  data_sample[i, ] = c(i, start_x, start_lambda)\n  \n  # generate new data for x and lambda based on sequentially updated conditional distributions\n  while (i &lt; n) {\n    \n    # record iteration\n    data_sample[i + 1, \"iteration\"] &lt;- i + 1\n    \n    # sample from x | lambda\n    data_sample[i + 1, \"X\"] &lt;- rexp(n = 1, rate = data_sample[i, \"lambda\"])\n    \n    # sample from lambda | x\n    data_sample[i + 1, \"lambda\"] &lt;- rgamma(n = 1, shape = alpha + 1, rate = data_sample[i + 1, \"X\"] + beta)\n    \n    # increase counter\n    i &lt;- i + 1\n  }\n  \n  return(data_sample)\n}\n\n# function to solve for density estimates\nestimate_density &lt;- function(input_values = 1, given_values = 1, equation = 1) {\n  \n  # calculate density estimate\n  density_estimate &lt;- equation(input_values, given_values) %&gt;% colMeans\n}\n\n# functions for application\n\n# function to generate random data from conditional distributions\ngenerate_sample_2 &lt;- function(k = 10000, alpha = 5, beta = 8, lambda = 12, \n                              start_x = 5, start_p = 0.5, start_n = 15, seed = 0) {\n  \n  # create dataframe\n  data_sample &lt;- matrix(data = NA, nrow = k, ncol = 4, dimnames = list(NULL, c(\"iteration\", \"X\", \"p\", \"n\")))\n  \n  # conditionally set random seed\n  if (seed &gt; 0) set.seed(seed)\n  \n  # initialize counter and starting values\n  i = 1\n  data_sample[i, ] = c(i, start_x, start_p, start_n)\n  \n  # generate new data for x, p and n based on sequentially updated conditional distributions\n  while (i &lt; k) {\n    \n    # record iteration\n    data_sample[i + 1, \"iteration\"] &lt;- i + 1\n    \n    # sample from x | p , n\n    data_sample[i + 1, \"X\"] &lt;- rbinom(n = 1, size = data_sample[i, \"n\"], prob = data_sample[i, \"p\"])\n    \n    # sample from p | x , n\n    data_sample[i + 1, \"p\"] &lt;- rbeta(n = 1, shape1 = data_sample[i + 1, \"X\"] + alpha, shape2 = data_sample[i, \"n\"] + beta - data_sample[i + 1, \"X\"])\n    \n    # sample from n - x | x , p and then calculate final n = (n - x) + x\n    data_sample[i + 1, \"n\"] &lt;- rpois(n = 1, lambda = lambda * (1 - data_sample[i + 1, \"p\"])) + data_sample[i + 1, \"X\"]\n    \n    # increase counter\n    i &lt;- i + 1\n  }\n  \n  return(data_sample)\n}\n\n# function to solve for density estimates\nestimate_density_2 &lt;- function(input_values = 1, given_values1 = 1, given_values2 = 1, equation = 1) {\n  \n  # calculate density estimate\n  density_estimate = equation(input_values, given_values1, given_values2) %&gt;% colMeans\n}\n\n# function to calculate mean of discrete probability distribution\ncalc_mean_2 &lt;- function(x = 1, p_x = 1) {\n  sum(x * p_x)\n}\n\n# function to calculate variance of discrete probability distribution\ncalc_var_2 &lt;- function(x = 1, p_x = 1) {\n  # calculate mean\n  mean &lt;- sum(x * p_x)\n  # calculate variance\n  sum(((x - mean)^2) * p_x)\n}\n\n### ----- Set global plot options ---- \n\n# create default storytelling with data theme\ntheme_swd = theme_minimal() + theme(\n  # titles and captions\n  plot.title = element_text(size = rel(1.75), color = \"grey30\"),\n  plot.subtitle = element_text(size = rel(1.25), color = \"grey30\"),\n  plot.caption = element_text(hjust = 0, color = \"grey30\"),\n  # axes\n  axis.title.x = element_text(hjust = 0, color = \"grey30\"),\n  axis.title.y = element_text(hjust = 1, color = \"grey30\"),\n  axis.line = element_line(color = \"grey90\"),\n  axis.ticks = element_line(color = \"grey90\"),\n  # plot background and gridlines\n  panel.background = element_blank(),\n  panel.grid.major = element_blank(),\n  panel.grid.minor = element_blank(),\n  # legend\n  legend.title = element_text(color = \"grey30\"),\n  legend.text = element_text(color = \"grey30\")\n)\n\n# set global plot theme\ntheme_set(theme_swd)\n\nUI\n\n### ----- Define UI ---- \n\n# create user interface\nui &lt;- fluidPage(\n  \n  tabsetPanel(id = \"tabs\",\n              tabPanel(\"Demo\",\n                       \n                       # application title\n                       titlePanel(\"Demonstrating the Properties of Gibbs Sampling using Simulation\"),\n                       \n                       # add sidebar\n                       sidebarPanel(\n                         \n                         # text block of description\n                         h4(tags$u(\"Description of problem\")),\n                         p(\"Let the size of a claim X be exponentially distributed with\n                             parameter λ. Further, treat the parameter λ as a random variable that follows\n                             a gamma distribution with parameters α and β. α and β are constants.\"),\n                         \n                         # section label\n                         h4(tags$u(\"Initialize info\")),\n                         \n                         # input number of iterations\n                         numericInput(\"n\", label = \"Number of iterations\",\n                                      value = 1000, min = 200, step = 100),\n                         \n                         # add columns within sidebar panel\n                         fluidRow(\n                           \n                           # first item\n                           column(width = 5, offset = 0,\n                                  # input alpha\n                                  # -&gt; even though the slider has a minimum, it still lets you type in something lower\n                                  # --&gt; so will have to fix that in the future somehow?\n                                  numericInput(\"alpha\", label = \"α\",\n                                               value = 5, min = 2, step = 1)),\n                           \n                           # second item\n                           column(width = 5, offset = 1,\n                                  # input beta\n                                  numericInput(\"beta\", label = \"β\",\n                                               value = 100, min = 2, step = 1))\n                         ), # fluid row\n                         \n                         # action button to explain results\n                         actionButton(\"run\", label = \"Run simulation\")\n                       ), # sidebar panel\n                       \n                       # add output spot\n                       mainPanel(\n                         \n                         # set tabs for different output\n                         tabsetPanel(id = \"tabs_demo\",\n                                     \n                                     # first tab\n                                     tabPanel(\"Diagnostic plots\",\n                                              \n                                              # scatter plots of last iterations\n                                              plotOutput(\"plot_scatter\"),\n                                              \n                                              # panel to display results of simulation after generating data\n                                              # -&gt; if want to have footer stay at bottom\n                                              # -&gt; conditionalPanel doesn't save space for the output, so can trick it into saving space with textOuput and renderText\n                                              # --&gt; then just use an if/else to have it print blank lines (ie save space), then print results\n                                              # --&gt; this way the footer wouldn't have to move when results are printed\n                                              # -&gt; but couldn't figure it out (can achieve this with HTML / CSS as well, but didn't want to figure it out)\n                                              conditionalPanel(condition = \"input.run != 0\",\n                                                               h4(tags$u(\"Results\")),\n                                                               p(\"These figures show the last 100 sampled values for X and λ, respectively.\n                                                                   We can see that there is no pattern among the generated random numbers\n                                                                   from the Gibbs sampling algorithm. Therefore, they can be considered\n                                                                   independent random samples.\")\n                                              ) # conditional panel\n                                     ), # tab panel\n                                     \n                                     # second tab\n                                     tabPanel(\"Sampled values\",\n                                              \n                                              # histograms of sampled values and marginal curves\n                                              plotOutput(\"plot_hist\"),\n                                              \n                                              # panel to display results of simulation after generating data\n                                              conditionalPanel(condition = \"input.run != 0\",\n                                                               h4(tags$u(\"Results\")),\n                                                               p(\"These histograms show values are generated from dependent sampling schemes,\n                                                                   which were based on the full conditional distributions of f(x|λ) and f(λ|x).\n                                                                   Additionally, the respective marginal density curves of X and λ are overlaid\n                                                                   on their corresponding histogram. The first 100 values of each sequence are\n                                                                   discarded as these are considered to be the burn-in iterations.\"),\n                                                               p(\"The marginal densities appear to line up very well with the sampled values,\n                                                                   which indicates the implemented dependent sampling schemes have generated random\n                                                                   samples from their respective marginal distributions.\")\n                                              ) # conditional panel\n                                     ), # tab panel\n                                     \n                                     # third tab\n                                     tabPanel(\"Estimated densities\",\n                                              \n                                              # plots of estimated and actual density curves\n                                              plotOutput(\"plot_est\"),\n                                              \n                                              # panel to display results of simulation after generating data\n                                              conditionalPanel(condition = \"input.run != 0\",                                                h4(tags$u(\"Results\")),\n                                                               p(\"By taking the simulated average of f(x|λ) over the sampled values of λ,\n                                                                   we obtain an estimate for the actual value of f(x) at the point x. These plots\n                                                                   show the estimated densities, which line up very well with the actual densities.\n                                                                   Therefore, we now have direct models of the respective target distributions.\")\n                                              ) # conditional panel\n                                     ) # tab panel\n                         ), # tab panel\n                         # footer\n                         h6(tags$footer(\"This app is an extension of:\",\n                                        tags$a(href = \"https://www.siam.org/Portals/0/Publications/SIURO/Volume%2011/S016609.pdf?ver=2018-06-13-135921-713\",\n                                               \"Implementation of Gibbs Sampling\n                                                         within Bayesian Inference and its Applications in Actuarial Science,\n                                                         SIAM Undergraduate Research Online, Vol. 11 (Gearhart, C. 2018)\"),\n                                        align = \"left\", style = \"\n                                          position: sticky;\n                                          border: 1px solid grey;\n                                          bottom: 0;\n                                          width: 100%;\n                                          height: 40px;\n                                          color: grey;\n                                          padding: 5px;\"\n                         )) # footer\n                       ) # main panel\n              ), # tab panel\n              tabPanel(\"Application\",\n                       \n                       # application title\n                       titlePanel(\"Application of Gibbs Sampling\"),\n                       \n                       # add sidebar\n                       sidebarPanel(\n                         \n                         # text block of description\n                         h4(tags$u(\"Description of problem\")),\n                         p(\"In order to model the number of claims for a portfolio, let claim probability P\n                            (as a random variable) follow a beta distribution with parameters α and β. Additionally,\n                            the total number of policies within a portfolio N follow a zero-truncated Poisson distribution\n                            with parameter λ.\"),\n                         p(\"Finally, assuming that filing a claim for a policy is independent and\n                            that the probability of filing a claim is constant throughout the lifetime of the policy,\n                            the number of policies that file a claim X can be modeled using a binomial distribution\n                            with parameters N and P.\"),\n                         \n                         # section label\n                         h4(tags$u(\"Initialize info\")),\n                         \n                         # input number of iterations\n                         numericInput(\"k_2\", label = \"Number of iterations\",\n                                      value = 1000, min = 200, step = 100),\n                         \n                         # input alpha\n                         numericInput(\"alpha_2\", label = \"α (weight on p)\",\n                                      value = 2, min = 1, step = 1),\n                         \n                         # input beta\n                         numericInput(\"beta_2\", label = \"β (weight on 1-p)\",\n                                      value = 8, min = 1, step = 1),\n                         \n                         # input lambda\n                         numericInput(\"lambda_2\", label = \"λ (avg number of policies)\",\n                                      value = 12, min = 1, step = 1),\n                         \n                         # action button to explain results\n                         actionButton(\"run_2\", label = \"Run simulation\")\n                         \n                       ), # sidebar panel\n                       \n                       # add output spot\n                       mainPanel(\n                         \n                         # plots of estimated density\n                         plotOutput(\"plot_est_2\"),\n                         \n                         # panel to display results of simulation after generating data\n                         conditionalPanel(condition = \"input.run_2 != 0\",  \n                                          h4(tags$u(\"Results\")),\n                                          p(\"By taking the simulated average of f(x|p,n) over the simulated values P\n                                              and N, a density estimate for the random variable X was be obtained. \n                                              This marginal distribution of X represents the number of policies that generate\n                                              a claim in a portfolio of N identical and independent policies,\n                                              each with a claim probability equal to P.\"),\n                                          p(\"This is an important results because in this particular model f(x) could not\n                                              be obtained in closed form. With the estimated density, actuaries can compute\n                                              many statistics for a portfolio with parameters p and n.\")\n                         ), # conditional panel\n                         \n                         # footer\n                         h6(tags$footer(\"This app is an extension of:\",\n                                        tags$a(href = \"https://www.siam.org/Portals/0/Publications/SIURO/Volume%2011/S016609.pdf?ver=2018-06-13-135921-713\",\n                                               \"Implementation of Gibbs Sampling\n                                                 within Bayesian Inference and its Applications in Actuarial Science,\n                                                 SIAM Undergraduate Research Online, Vol. 11 (Gearhart, C. 2018)\"),\n                                        align = \"left\", style = \"\n                                          position: sticky;\n                                          border: 1px solid grey;\n                                          bottom: 0;\n                                          width: 100%;\n                                          height: 40px;\n                                          color: grey;\n                                          padding: 5px;\"\n                         )) # footer\n                         \n                       ) # main panel\n              ) # tab panel\n  ) # tabset panel\n) # fluid page\n\nServer\n\n### ----- Define server ---- \n\n# how to get simulation to run every time run button is hit? not just if the inputs changed and button was hit\n# create server\nserver &lt;- function(input, output) {\n  \n  # Demo -&gt; Functions for data ------------------------\n  \n  # function to generate data and create modified datasets\n  # -&gt; call this function in place of the 'dataframe' if need to create a modified dataset or make a plot\n  # -&gt; returns a list of the modified datasets\n  get_new_data &lt;- reactive({\n    \n    # create object to store datasets\n    data &lt;- list(data_sample = NULL, data_scatter = NULL, data_sample2 = NULL)\n    \n    # sample from conditional distributions \n    data[[\"data_sample\"]] &lt;- generate_sample(n = input$n, alpha = input$alpha, beta = input$beta)\n    \n    # create data for scatterplot\n    data[[\"data_scatter\"]] &lt;- data[[\"data_sample\"]] %&gt;%\n      data.frame %&gt;%\n      filter(iteration &gt; input$n - 100)\n    \n    # set number of burn-in iterations\n    burn_in &lt;- 100\n    \n    # remove burn-in iteration\n    data[[\"data_sample2\"]] &lt;- data[[\"data_sample\"]] %&gt;% \n      data.frame %&gt;% \n      filter(iteration &gt; burn_in)\n    \n    return(data)\n    \n  }) # event reactive\n  \n  # function to perform calculations for x\n  density_x_given_lambda &lt;- function(X = 1, Lambda = 1) {\n    \n    # specify density equation\n    Lambda*exp(-Lambda*X)\n  }\n  \n  # function to perform calculations for lambda\n  density_lambda_given_x &lt;- function(Lambda = 1, X = 1, alpha = input$alpha, beta = input$beta) {\n    \n    # specify density equation\n    (((X + beta)^(alpha + 1)) * (Lambda^alpha) * exp(-Lambda * (X + beta))) / gamma(alpha + 1)\n  }\n  \n  # Demo -&gt; Create diagnostic plots --------------------\n  \n  # render scatterplot after generating new data\n  output$plot_scatter &lt;- renderPlot({\n    \n    # take a dependency on action button\n    # -&gt; and prevent it from returning a plot the first time (ie don't run code until action button is hit)\n    if (input$run == 0) {return()}\n    \n    # use isolate to avoid dependency on action button\n    isolate({\n      \n      # # create scatterplots of last iterations to visually check for randomness\n      # # -&gt; x plot\n      plot_scatter_x &lt;- ggplot() +\n        geom_point(aes(x = iteration, y = X),\n                   color = \"black\", fill = \"white\", shape = 21, size = 1, stroke = 0.5,\n                   data = get_new_data()[[\"data_scatter\"]]) +\n        labs(title = \"Scatterplot of generated \\nsampled values for X\", x = \"Iteration\", y = \"x\")\n      \n      # # -&gt; lambda plot\n      plot_scatter_lambda &lt;- ggplot() +\n        geom_point(aes(x = iteration, y = lambda),\n                   color = \"black\", fill = \"white\", shape = 21, size = 1, stroke = 0.5,\n                   data = get_new_data()[[\"data_scatter\"]]) +\n        labs(title = \"Scatterplot of generated \\nsampled values for λ\", x = \"Iteration\", y = expression(lambda))\n      \n      # display plots\n      ggarrange(plot_scatter_x, plot_scatter_lambda)\n      \n    }) # isolate\n  }) # render plot\n  \n  # Demo -&gt; Create histograms of sampled values and include density curves --------------------\n  \n  # render histograms after generating new data\n  output$plot_hist &lt;- renderPlot({\n    \n    # take a dependency on action button\n    # -&gt; and prevent it from returning a plot the first time (ie don't run code until action button is hit)\n    if (input$run == 0) {return()}\n    \n    # use isolate to avoid dependency on action button\n    isolate({\n      \n      # set maximum for x plot\n      limit_x = quantile(get_new_data()[[\"data_sample2\"]]$X, 0.995)\n      \n      # create histogram of x with marginal density curve overlaid\n      plot_hist_x &lt;- ggplot() +\n        geom_histogram(aes(x = X, y = ..density.., fill = \"Sampled values\"),\n                       bins = 40, color = \"grey60\",\n                       data = get_new_data()[[\"data_sample2\"]]) +\n        stat_function(aes(x = x, color = \"Actual density\"),\n                      fun = dpareto2, args = list(shape = input$alpha, scale = input$beta),\n                      data = data.frame(x = c(0, limit_x)),\n                      n = 100000, size = 0.75) +\n        coord_cartesian(xlim = c(0, limit_x)) +\n        scale_fill_manual(values = \"white\") +\n        scale_color_manual(values = \"grey40\") +\n        labs(title = \"Histogram of generated \\nsample values of X\", x = \"x\",\n             color = \"\", fill = \"\") +\n        theme(legend.position = \"bottom\")\n      \n      # create histogram of lambda with marginal density curve overlaid\n      plot_hist_lambda &lt;- ggplot() +\n        geom_histogram(aes(x = lambda, y = ..density.., fill = \"Sampled values\"),\n                       bins = 40, color = \"grey60\",\n                       data = get_new_data()[[\"data_sample2\"]]) +\n        stat_function(aes(x = x, color = \"Actual density\"),\n                      fun = dgamma, args = list(shape = input$alpha, rate = input$beta),\n                      data = data.frame(x = c(0, max(get_new_data()[[\"data_sample2\"]]$lambda))),\n                      n = 100000, size = 0.75) +\n        scale_fill_manual(values = \"white\") +\n        scale_color_manual(values = \"grey40\") +\n        labs(title = \"Histogram of generated \\nsample values of λ\", x = expression(lambda),\n             color = \"\", fill = \"\") +\n        theme(legend.position = \"bottom\")\n      \n      # display plots\n      ggarrange(plot_hist_x, plot_hist_lambda)\n      \n    }) # isolate\n  }) # render plot\n  \n  # Demo -&gt; Solve for estimated densities & create plots of estimated densities and actual densities ------------------------------------------\n  \n  # render scatterplot after generating new data\n  output$plot_est &lt;- renderPlot({\n    \n    # take a dependency on action button\n    # -&gt; and prevent it from returning a plot the first time (ie don't run code until action button is hit)\n    if (input$run == 0) {return()}\n    \n    # use isolate to avoid dependency on action button\n    isolate({\n      \n      # set max for plot and calculate points to estimate density of x at (if is to make sure step isn't zero)\n      step_x &lt;- ifelse(diff(range(get_new_data()[[\"data_sample2\"]]$X)) &gt; 1,\n                       round((quantile(get_new_data()[[\"data_sample2\"]]$X, 0.995) - min(get_new_data()[[\"data_sample2\"]]$X))/40, 5) %&gt;% as.numeric,\n                       0.01)\n      \n      # set maximum for lambda plot\n      limit_x &lt;- quantile(get_new_data()[[\"data_sample2\"]]$X, 0.995)\n      \n      # create matrices of data to be used for x\n      values_x &lt;- seq(0, limit_x, by = step_x)\n      X1 &lt;- matrix(data = , values_x, nrow = nrow(get_new_data()[[\"data_sample2\"]]), ncol = length(values_x), byrow = TRUE)\n      Lambda1 &lt;- matrix(data = get_new_data()[[\"data_sample2\"]]$lambda, nrow = nrow(get_new_data()[[\"data_sample2\"]]), ncol = ncol(X1))\n      \n      # calculate density estimates for f(x)\n      data_estimated_x &lt;- estimate_density(input_values = X1, given_values = Lambda1, equation = density_x_given_lambda) %&gt;% \n        data.frame(x = values_x, f_x_hat = .)\n      \n      # set max for plot and  calculate points to estimate density of lambda at (if is to make sure step isn't zero)\n      step_lambda &lt;- ifelse(diff(range(get_new_data()[[\"data_sample2\"]]$lambda)) &gt; 1,\n                            round((quantile(get_new_data()[[\"data_sample2\"]]$lambda, 0.995) - min(get_new_data()[[\"data_sample2\"]]$lambda))/40, 5) %&gt;% as.numeric,\n                            0.01)\n      \n      # create matrices of data to be used for lambda\n      values_lambda &lt;- seq(0, max(get_new_data()[[\"data_sample2\"]]$lambda), by = step_lambda)\n      Lambda2 &lt;- matrix(data = , values_lambda, nrow = nrow(get_new_data()[[\"data_sample2\"]]), ncol = length(values_lambda), byrow = TRUE)\n      X2 &lt;- matrix(data = get_new_data()[[\"data_sample2\"]]$X, nrow = nrow(get_new_data()[[\"data_sample2\"]]), ncol = ncol(Lambda2))\n      \n      # calculate density estimates for f(lambda)\n      data_estimated_lambda &lt;- estimate_density(input_values = Lambda2, given_values = X2, density_lambda_given_x) %&gt;% \n        data.frame(lambda = values_lambda, f_lambda_hat = .)\n      \n      # X plot\n      # -&gt; density estimates with marginal density curve overlaid\n      plot_estimated_x &lt;- ggplot() +\n        geom_point(aes(x = x, y = f_x_hat, fill = \"Estimated density\"),\n                   color = \"black\", shape = 21, size = 2, stroke = 1,\n                   data = data_estimated_x) +\n        stat_function(aes(x = x, color = \"Actual density\"),\n                      fun = dpareto2, args = list(shape = input$alpha, scale = input$beta),\n                      data = data.frame(x = c(0, limit_x)),\n                      n = 100000, size = 0.75) +\n        coord_cartesian(xlim = c(0, limit_x)) +\n        scale_fill_manual(values = \"white\") +\n        scale_color_manual(values = \"grey60\") +\n        labs(title = \"Estimated and actual density of X\", x = \"x\", y = expression(f(hat(x))),\n             color = \"\", fill = \"\") +\n        theme(legend.position = \"bottom\")\n      \n      # Lambda plot\n      # -&gt; density estimates with marginal density curve overlaid\n      plot_estimated_lambda &lt;- ggplot() +\n        geom_point(aes(x = lambda, y = f_lambda_hat, fill = \"Estimated density\"),\n                   color = \"black\", shape = 21, size = 2, stroke = 1,\n                   data = data_estimated_lambda) +\n        stat_function(aes(x = x, color = \"Actual density\"),\n                      fun = dgamma, args = list(shape = input$alpha, rate = input$beta),\n                      data = data.frame(x = c(0, max(get_new_data()[[\"data_sample2\"]]$lambda))),\n                      n = 100000, size = 0.75) +\n        scale_fill_manual(values = \"white\") +\n        scale_color_manual(values = \"grey60\") +\n        labs(title = \"Estimated and actual density of  λ\", x = expression(lambda), y = expression(f(hat(lambda))),\n             color = \"\", fill = \"\") +\n        theme(legend.position = \"bottom\")\n      \n      # display plots\n      ggarrange(plot_estimated_x, plot_estimated_lambda)\n      \n    }) # isolate\n  }) # render plot\n  \n  # Application -&gt; Functions for data ------------------------\n  \n  # function to generate data and create modified datasets\n  # -&gt; returns a list of the modified datasets\n  get_new_data_2 &lt;- reactive({\n    \n    # create object to store datasets\n    data_2 &lt;- list(data_sample = NULL, data_sample2 = NULL)\n    \n    # sample from conditional distributions \n    data_2[[\"data_sample\"]] &lt;- generate_sample_2(k = input$k_2, alpha = input$alpha_2, beta = input$beta_2, lambda = input$lambda_2)\n    \n    # set number of burn-in iterations\n    burn_in_2 &lt;- 100\n    \n    # remove burn-in iteration\n    data_2[[\"data_sample2\"]] &lt;- data_2[[\"data_sample\"]] %&gt;% \n      data.frame %&gt;% \n      filter(iteration &gt; burn_in_2)\n    \n    return(data_2)\n    \n  }) # event reactive\n  \n  # function to perform calculations for x\n  # -&gt; x is technically a pmf\n  density_x_given_p_and_n_2 &lt;- function(X = 1, P = 0.5, N = 1) {\n    \n    # specify density equation\n    choose(N, X) * P^X * (1 - P)^(N - X)\n  }\n  \n  # Application -&gt; Solve for estimated densities & and create plot of estimated density ------------------------\n  \n  # render scatterplot after generating new data\n  output$plot_est_2 &lt;- renderPlot({\n    \n    # take a dependency on action button\n    # -&gt; and prevent it from returning a plot the first time (ie don't run code until action button is hit)\n    if (input$run_2 == 0) {return()}\n    \n    # use isolate to avoid dependency on action button\n    isolate({\n      \n      # determine step size for x values\n      if (diff(range(get_new_data_2()[[\"data_sample2\"]]$X)) &gt; 75) {\n        step &lt;- 5\n      } else {\n        step &lt;- 1\n      }\n      \n      # create matrices of data to be used for x\n      values_x_2 &lt;- seq(min(get_new_data_2()[[\"data_sample2\"]]$X), max(get_new_data_2()[[\"data_sample2\"]]$X), by = step)\n      X_2 &lt;- matrix(data = , values_x_2, nrow = nrow(get_new_data_2()[[\"data_sample2\"]]), ncol = length(values_x_2), byrow = TRUE)\n      P_2 &lt;- matrix(data = get_new_data_2()[[\"data_sample2\"]]$p, nrow = nrow(get_new_data_2()[[\"data_sample2\"]]), ncol = ncol(X_2))\n      N_2 &lt;- matrix(data = get_new_data_2()[[\"data_sample2\"]]$n, nrow = nrow(get_new_data_2()[[\"data_sample2\"]]), ncol = ncol(X_2))\n      \n      # calculate density estimates for f(x) and scale so that probabilities sum to one\n      # -&gt; with a step of 1, it is always super close to 1\n      # --&gt; but if use a different step size, need to scale probabilities\n      data_estimated_x_2 &lt;- estimate_density_2(input_values = X_2, given_values1 = P_2, given_values2 = N_2, equation = density_x_given_p_and_n_2) %&gt;% \n        data.frame(x = values_x_2, f_x_hat = .) %&gt;% \n        mutate(f_x_hat = f_x_hat/sum(f_x_hat))\n      \n      # calculate mean\n      x_mean_2 &lt;- round(calc_mean_2(x = data_estimated_x_2$x, p_x = data_estimated_x_2$f_x_hat), 3)\n      \n      # calculate variance\n      x_var_2 &lt;- round(calc_var_2(x = data_estimated_x_2$x, p_x = data_estimated_x_2$f_x_hat), 3)\n      \n      # X plot\n      # -&gt; density estimates with marginal density curve overlaid\n      p_2 &lt;- ggplot() +\n        geom_point(aes(x = x, y = f_x_hat, fill = \"Estimated density\"),\n                   color = \"black\", shape = 21, size = 2, stroke = 1,\n                   data = data_estimated_x_2) +\n        geom_linerange(aes(x = x, ymax = f_x_hat),\n                       ymin = 0,\n                       data = data_estimated_x_2) +\n        scale_fill_manual(values = \"white\") +\n        annotate(\"text\", x = Inf, y = Inf, hjust = 1, vjust = 1,\n                 label = paste0(\"mean = \", x_mean_2, \"\\nvar = \", x_var_2)) +\n        labs(title = \"Estimated density of X\", x = \"x\", y = expression(hat(f(x))),\n             fill = \"\") +\n        theme(legend.position = \"bottom\")\n      \n      # display plot\n      p_2\n      \n    }) # isolate\n  }) # render plot\n  \n} # server\n\nCombine\n\n### ---- Run app ---- \n\nshinyApp(ui, server)",
    "crumbs": [
      "Greaves"
    ]
  },
  {
    "objectID": "interview.html",
    "href": "interview.html",
    "title": "Interview",
    "section": "",
    "text": "Dashboard",
    "crumbs": [
      "Interview"
    ]
  },
  {
    "objectID": "interview.html#dashboard",
    "href": "interview.html#dashboard",
    "title": "Interview",
    "section": "",
    "text": "Tab 1\n\nTab 2\n\nTab 3",
    "crumbs": [
      "Interview"
    ]
  },
  {
    "objectID": "interview.html#code",
    "href": "interview.html#code",
    "title": "Interview",
    "section": "Code",
    "text": "Code\nPre code\n\n### ---- Load packages and set options ----\n\n# load necessary packages\nlibrary(tidyverse)\nlibrary(magrittr)\nlibrary(shiny)\nlibrary(ggpubr)\nlibrary(shinythemes)\n\n# create default storytelling with data theme\ntheme_swd &lt;- theme_minimal() + \n  \n  theme(\n    # titles and captions\n    plot.title = element_text(size = rel(1.75),\n                              color = \"grey30\"),\n    plot.subtitle = element_text(size = rel(1.25),\n                                 color = \"grey30\"),\n    plot.caption = element_text(hjust = 0,\n                                color = \"grey30\"),\n    # axes\n    axis.title.x = element_text(hjust = 0,\n                                color = \"grey30\"),\n    axis.title.y = element_text(hjust = 1,\n                                color = \"grey30\"),\n    axis.line = element_line(color = \"grey90\"),\n    axis.ticks = element_line(color = \"grey90\"),\n    # plot background and gridlines\n    panel.background = element_blank(),\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    # legend\n    legend.title = element_text(color = \"grey30\"),\n    legend.text = element_text(color = \"grey30\")\n  )\n\n# set global plot theme\ntheme_set(theme_swd)\n\nUI\n\n### ---- Define UI ----\n\n# create user interface\n# -&gt; set shiny theme as well\nui &lt;- fluidPage(theme = shinytheme(\"flatly\"),\n                \n                #tabsetPanel(id = \"tabs\",\n                #tabPanel(\"Normal\",\n                \n                # application title\n                titlePanel(\"Example: Normal Likelihood\"),\n                \n                # add sidebar\n                sidebarPanel(\n                  \n                  # sectin label\n                  h4(tags$u(\"Problem Setup\")),\n                  \n                  # text block of description and formulas\n                  # -&gt; this is how to do it with just typing it in there...\n                  # p(\"Let X1,..., Xn be iid N(μ, σ^2) where σ^2 is known. Find the likelihood function L(μ | x) and find the Maximum Likelihood Estimator (MLE) of μ.\"),\n                  # p(\"Recall if Xi ~ N(μ, σ), then:\"),\n                  # p(withMathJax(\"$$f(x_i \\\\mid \\\\mu) = (2 \\\\pi)^{-1/2} \\\\exp \\\\big\\\\{-\\\\frac{1}{2} \\\\big(\\\\frac{x_i - \\\\mu}{\\\\sigma}\\\\big)^2\\\\big\\\\}, \\\\\\\\x_i, \\\\mu \\\\in (-\\\\infty, \\\\infty) \\\\quad \\\\& \\\\quad \\\\sigma &gt; 0.$$\")),\n                  \n                  \n                  # insert image with the problem setup\n                  # resource for how to get poictures in-&gt; http://shiny.rstudio-staging.com/tutorial/written-tutorial/lesson2/\n                  img(src = \"problem-setup.png\",\n                      height = 150,\n                      width = 325),\n                  \n                  # just using this to space things out\n                  # probably a better way, but this suffices for now...\n                  p(tags$br()),\n                  \n                  p(tags$i(\"Initialize Parameter Values and Sample Size:\")),\n                  \n                  # add columns within sidebar panel\n                  fluidRow(\n                    \n                    # first item\n                    column(width = 3,\n                           # input true value for the parameter of interest mu\n                           # -&gt; default to zero so that it is the standard normal curve\n                           # -&gt; no restrictions on the value\n                           numericInput(\"theta\",\n                                        label = \"μ\",\n                                        value = 0)),\n                    \n                    # second item\n                    column(width = 3,\n                           # input value for the other needed parameter\n                           # -&gt; default to one so that it is the standard normal curve\n                           # -&gt; must be positive\n                           # -&gt; ????? investigate if need to increase to 0.001 or something like that\n                           # -&gt; ?? and can you still run it with a negative? or type it in?\n                           numericInput(\"sigma\", \n                                        label = \"σ\",\n                                        value = 1,\n                                        min = 0)),\n                    \n                    # second item\n                    column(width = 6,\n                           #  slider to input sample size\n                           sliderInput(inputId = \"sample_size\",\n                                       label = \"n\",\n                                       min = 5,\n                                       max = 500,\n                                       value = 25,\n                                       step = 5,\n                                       round = FALSE,\n                                       ticks = FALSE))\n                    \n                  ), # fluid row\n                  \n                  # section label\n                  h4(tags$u(\"Solution Steps\")),\n                  \n                  # insert image with the written steps\n                  img(src = \"steps-written.png\",\n                      height = 100,\n                      width = 325),\n                  \n                  p(tags$br()),\n                  \n                  # section label\n                  h4(tags$u(\"Get Results\")),\n                  \n                  # action button to generate data\n                  actionButton(inputId = \"run\",\n                               label = tags$b(\"Simulate Data\"),\n                               icon = icon(name = \"dragon\")),\n                  p(\"\"),\n                  \n                  # text description\n                  p(tags$i(\"Show additional information:\")),\n                  \n                  # check boxes for whether or not to include extra info\n                  checkboxInput(inputId = \"show_derivations\",\n                                label = \"Derivations\",\n                                value = FALSE),\n                  \n                  checkboxInput(inputId = \"show_est\",\n                                label = \"Estimated MLE\",\n                                value = FALSE),\n                  \n                  checkboxInput(inputId = \"show_true\",\n                                label = \"True Paramter\",\n                                value = FALSE)\n                  \n                ), # sidebar panel\n                \n                # add output spot\n                mainPanel(\n                  \n                  # set tabs for different output\n                  tabsetPanel(id = \"tabs_step1\",\n                              \n                              # first tab\n                              tabPanel(\"Step 1\",\n                                       \n                                       # plot of joint denstiy function\n                                       plotOutput(\"plot_joint_density\"),\n                                       \n                                       # panel to display results of simulation after generating data\n                                       conditionalPanel(condition = \"input.show_derivations == 1\",\n                                                        h4(tags$u(\"Derivations\")),\n                                                        # insert image with joint density derivation\n                                                        img(src = \"step1.png\",\n                                                            height = 100,\n                                                            width = 325),\n                                       ) # conditional panel\n                              ), # tab panel\n                              \n                              # second tab\n                              tabPanel(\"Step 2\",\n                                       \n                                       # histograms of sampled values and marginal curves\n                                       plotOutput(\"plot_liks\"),\n                                       \n                                       # panel to display results of simulation after generating data\n                                       conditionalPanel(condition = \"input.show_derivations == 1\",\n                                                        h4(tags$u(\"Derivations\")),\n                                                        # insert image with likelihood and log-likelihood function derivations\n                                                        img(src = \"step2.png\",\n                                                            height = 150,\n                                                            width = 250),\n                                       ) # conditional panel\n                              ), # tab panel\n                              \n                              # third tab\n                              tabPanel(\"Step 3\",\n                                       \n                                       # plots of estimated and actual density curves\n                                       plotOutput(\"plot_derivatives\"),\n                                       \n                                       # panel to display results of simulation after generating data\n                                       conditionalPanel(condition = \"input.show_derivations == 1\",                                                \n                                                        h4(tags$u(\"Derivations\")),\n                                                        # insert image with derivatives of log likelihood derivations\n                                                        img(src = \"step3.png\",\n                                                            height = 300,\n                                                            width = 300)\n                                       ) # conditional panel\n                              ) # tab panel\n                  ) # tab panel\n                ) # main panel\n                #         ) # tab panel\n                \n                # ) # tabset panel\n) # fluid page\n\nServer\n\n### ---- Define server ----\n\n# create server\nserver &lt;- function(input, output) {\n  \n  ## --- Simulate data and perform calculations for the normal likelihood example ----\n  \n  # function to generate data and create modified datasets\n  # -&gt; call this function in place of the 'dataframe' if need to create a modified dataset or make a plot\n  # -&gt; returns a list of the modified datasets\n  get_new_data &lt;- reactive({\n    \n    # set random seed\n    # -&gt; set the the value of the action button so that it takes dependence on it and will cause this data function to be rerun each time the button is clicked\n    set.seed(input$run)\n    \n    # create object to store datasets\n    data &lt;- list(data_x = NULL, data_mle = NULL, data_max_lik = NULL, data_true_lik = NULL)\n    \n    # NOTE on code\n    # using theta as the parameter of interest for all of the code so that it is general and can easily adapt to new situation\n    # can change to my or alpha or whatever it should be on the plot labels when finalizing\n    \n    # initialize info\n    # -&gt; sample size\n    # -&gt; parameter and sample size information are specified by the user, so don't have to initialize those\n    groups &lt;- c(\"curve\",\n                \"sample\")\n    \n    # simulate data\n    # \"sampling\" x data to cover the range of the curve so that can get a picture of the whole distribution\n    # -&gt; so just use the mean +/- 3 sd and make the sequence a set length so that it doesn't depend on the values of theta and sigma\n    # -&gt; assuming standard normal population curve\n    # then use the density function to get the functional values at each of the sampled xs\n    data[[\"data_x\"]] &lt;- data.frame(x = seq(from = input$theta - 3 * input$sigma,\n                                           to = input$theta + 3 * input$sigma,\n                                           length.out = 100),\n                                   group = groups[1]) %&gt;% \n      bind_rows(data.frame(x = rnorm(n = input$sample_size,\n                                     mean = input$theta,\n                                     sd = input$sigma),\n                           group = groups[2])) %&gt;% \n      mutate(f_x = dnorm(x = x,\n                         mean = input$theta,\n                         sd = input$sigma)) %&gt;% \n      select(group, x, f_x)\n    \n    # initialize vector of potential values for the estimator of theta, the main parameter of interest\n    # -&gt; setting values to span several values to either side, but keeping general so still works regardless of the scale\n    # -&gt; and make a set length, which is the total number of parameter values to use (making larger cause not showing points on the likelihood plots, so can be more fine)\n    # also add in the true parameter value so that it is the max of the likelihood\n    # then sort to be in increasing order\n    theta_hat &lt;- c(seq(from = input$theta - 0.5 * input$sigma,\n                       to = input$theta + 0.5 * input$sigma,\n                       length.out = 1000),\n                   input$theta) %&gt;% \n      sort\n    \n    # do a series of calculations to create information needed to plot different mle related functions\n    # lapply() allows the function to do the same set of calculations for each of the different theta_hats\n    # then finally combine all the rows into a single organized dataframe, where each row (theta_hat value) / column (all other columns) pair represents an (x,y) coordinate for plots showing the different steps in the mle process\n    data[[\"data_mle\"]] &lt;- lapply(X = theta_hat, FUN = function(theta_hat_i, x_data){\n      \n      # calculate the value of the likelihood function for the specific theta_hat value\n      # -&gt; just does the product of the (density) functional values of each of the observed xs under the population distribution with the newly assumed parameter value\n      # -&gt; result is just a single number\n      # -&gt; these steps are following the derived formula for the likelihood\n      # --&gt; just able to use dnorm() and the prod() function to do the heavy lifting\n      likelihood &lt;- dnorm(x = x_data$x,\n                          mean = theta_hat_i,\n                          sd = input$sigma) %&gt;% \n        prod\n      \n      # calculate the log-likelihood by doing a log transformation\n      loglik &lt;- log(likelihood)\n      \n      # calculate the first derivative of the loglik\n      # -&gt; still uses the derived formulas, except this time there is no function \"shortcut\" \n      d_loglik &lt;- sum(x_data$x) - nrow(x_data) * theta_hat_i\n      \n      # calculate the second derivative of the loglik\n      # -&gt; still uses the derived formulas, except this time there is no function \"shortcut\" \n      d2_loglik &lt;- -1 * nrow(x_data)\n      \n      # combine results into a single dataframe indexed by the specific theta_hat and return\n      # -&gt; result is a one row dataframe with MLE related info under this parameter value\n      data.frame(theta_hat = theta_hat_i,\n                 likelihood,\n                 loglik,\n                 d_loglik,\n                 d2_loglik) %&gt;% \n        return\n      \n    }, x_data = filter(data[[\"data_x\"]], group == \"sample\")) %&gt;% \n      Reduce(f = bind_rows,\n             x = .)\n    \n    # find the row with the max likelihood\n    # use head() to ensure that the resulting dataframe only has one row\n    # -&gt; if th max likelihood value matched to more than one theta_hat value, then multiple MLE lines would be plotted which is not desired\n    # -&gt; so now een if there is multiple, head will only return one (and obviously they will be so close together) and if there is only a unique max this wont throw an error\n    data[[\"data_max_lik\"]] &lt;- data[[\"data_mle\"]] %&gt;% \n      filter(likelihood == max(likelihood)) %&gt;% \n      head(n = 1)\n    \n    # not flawless cause with a sample size of like 1000 something goes weird with the likelihood function...\n    # but good enough\n    \n    # find the row with the theta_hat of the true parameter value\n    data[[\"data_true_lik\"]] &lt;- data[[\"data_mle\"]]  %&gt;% \n      filter(theta_hat == input$theta)\n    \n    # return list of the four datasets\n    return(data)\n    \n  }) # event reactive\n  \n  ## ---- Plot of joint density ----\n  \n  # render plot of joint density after generating new data\n  output$plot_joint_density &lt;- renderPlot({\n    \n    # take a dependency on action button\n    # -&gt; and prevent it from returning a plot the first time (ie don't run code until action button is hit)\n    if (input$run == 0) {\n      return()\n    }\n    \n    # use isolate to avoid dependency on action button\n    isolate({\n      \n      # this is a make-shift way of preventing the code from running if an invalid standard deviation value is entered\n      # -&gt; the condition makes sure this code block doesn't run before hitting the button for the first time and only for an invalid sigma value\n      if (input$run != 0 & input$sigma &lt;= 0) {\n        \n        # create an empty plot essentially that contains the desired error message\n        g &lt;- ggplot() + \n          annotate(geom = \"text\",\n                   label = \"Please enter a value for σ greater than zero!\",\n                   color = \"red\",\n                   x = 1,\n                   y = 1) +\n          theme_void()\n        \n        # return plot\n        # -&gt; for some reason, the () strategy and using plot() doesnt work??\n        # -&gt; but it does work as desired if you explicitly return the plot object\n        return(g)\n        \n      }\n      \n      # create base plot of sample data and joint density function\n      # points are the functional values at the observed xs plotted on the assumed population curve (for visual purposes)\n      # line plot of the theoretical joint density\n      # having to do the trick with the aes labels to get the legend to show up with meaningful labels\n      # placing the legend at the bottom\n      plot_joint_density &lt;- ggplot() + \n          geom_point(aes(x = x,\n                         y = f_x,\n                         fill = \"Sampled Values\"),\n                     data = filter(get_new_data()[[\"data_x\"]], group == \"sample\"),\n                     shape = 1,\n                     size = 2,\n                     stroke = 0.75,\n                     color = \"grey30\") + \n          geom_line(aes(x = x,\n                        y = f_x,\n                        color = \"Population Distribution\"),\n                    data = filter(get_new_data()[[\"data_x\"]], group == \"curve\")) + \n          scale_fill_manual(values = \"white\") + \n          scale_color_manual(values = \"grey40\") + \n          labs(x = expression(x),\n               y = expression(f(x)),\n               color = \"\",\n               fill = \"\") + \n          theme(legend.position = \"bottom\")\n      \n      # set initial plot to be displayed\n      # -&gt; better description of how this works with the likelihood plots\n      plot_joint_density_display &lt;- plot_joint_density\n      \n      # add theoretical (true) parameter information to the joint density plot\n      # -&gt; this is to reinforce the idea that the sample data was under a normal distribution with this particular mean\n      # -&gt; but when calculating the likelihood, that curve shifts\n      if(input$show_true == 1) {\n        \n        plot_joint_density_display &lt;- plot_joint_density +\n          geom_vline(xintercept = input$theta,\n                     color = \"orange\",\n                     alpha = 0.5) +\n          annotate(geom = \"text\",\n                   label = paste0(\"\\u03BC = \", input$theta),\n                   x = -Inf,\n                   y = Inf,\n                   hjust = 0,\n                   vjust = 1,\n                   color = \"orange\")\n        \n      }\n      \n      # display plot\n      plot(plot_joint_density_display)\n        \n      \n    }) # isolate\n  }) # render plot\n  \n  ## ---- Plot of likelihood and log likelihood ----\n  \n  # render likelihood and log likelihood plots after generating new data\n  output$plot_liks &lt;- renderPlot({\n    \n    # take a dependency on action button\n    # -&gt; and prevent it from returning a plot the first time (ie don't run code until action button is hit)\n    if (input$run == 0) {return()}\n    \n    # use isolate to avoid dependency on action button\n    isolate({\n      \n      # error check for invalid standard deviation value\n      if (input$run != 0 & input$sigma &lt;= 0) {\n        \n        # create an empty plot essentially that contains the desired error message\n        g &lt;- ggplot() + \n          annotate(geom = \"text\",\n                   label = \"Please enter a value for σ greater than zero!\",\n                   color = \"red\",\n                   x = 1,\n                   y = 1) +\n          theme_void()\n        \n        # return plot\n        return(g)\n        \n      }\n      \n      # create base plot of likelihood function\n      # line is the likelihood values across the set of theta hat values\n      # -&gt; not showing the points so that the joint density plot isn't as easily confused with this new set of plots\n      plot_lik &lt;- ggplot() + \n        geom_line(aes(x = theta_hat,\n                      y = likelihood,\n                      color = \"Likelihood Function\"),\n                  data = get_new_data()[[\"data_mle\"]]) + \n        scale_fill_manual(values = \"white\") + \n        scale_color_manual(values = \"grey30\") + \n        labs(x = expression(hat(mu)),\n             y = expression(\"L(\"~mu~\"|\"~x~\")\"),\n             color = \"\",\n             fill = \"\") + \n        theme(legend.position = \"bottom\")\n      \n      # set initial plot to be displayed\n      # -&gt; then conditionally update (based on the checkboxes) which information gets added to the plot that will be displayed\n      # -&gt; if conditions are met, the plot object for the display plot will be updated accordingly\n      # -&gt; this same-named but potentially updated plot object is what will then be given to ggarrange()\n      # this is the default and is like the if(input$show_est == 0 & input$show_est == 0) condition\n      plot_lik_displayed &lt;- plot_lik\n      \n      # add estimated MLE information to the base likelihood plot\n      # -&gt; the two lines cross, which is just a cool visual feature\n      # -&gt; using blue for all these features, and the lines are slightly transparent so they don't stand out too much\n      # vertical line is at the theta_hat value where the likelihood function is maximized\n      # horizontal line is at the functional value at the estimated MLE\n      # then add an annotation for what the actual estimated MLE value is\n      if(input$show_est == 1 & input$show_true == 0) {\n        \n        plot_lik_displayed &lt;- plot_lik +\n          geom_vline(xintercept = get_new_data()[[\"data_max_lik\"]]$theta_hat,\n                     color = \"blue\",\n                     alpha = 0.5) +\n          geom_hline(yintercept = get_new_data()[[\"data_max_lik\"]]$likelihood,\n                     color = \"blue\",\n                     alpha = 0.5) +\n          annotate(geom = \"text\",\n                   label = paste0(\"MLE ≈ \", round(get_new_data()[[\"data_max_lik\"]]$theta_hat, 3)),\n                   x = Inf,\n                   y = Inf,\n                   hjust = 1,\n                   vjust = 1,\n                   color = \"blue\")\n        \n      }\n      \n      # add theoretical (true) parameter information to the base likelihood plot\n      # -&gt; the two lines cross, which is just a cool visual feature\n      # -&gt; using orange for all these features\n      # vertical line is at the theta value used to generate the sample data\n      # -&gt; this will be slightly different than the theta_hat value where the likelihood function is maximized, as it should be\n      # horizontal line is at the functional value for the true parameter value\n      # -&gt; again will not be at the max of the likelihood function because the likelihood is based on the sample data, so sampling variability\n      # then add an annotation for what the true value is\n      if(input$show_est == 0 & input$show_true == 1) {\n        \n        plot_lik_displayed &lt;- plot_lik +\n          geom_vline(xintercept = input$theta,\n                     color = \"orange\",\n                     alpha = 0.5) +\n          geom_hline(yintercept = get_new_data()[[\"data_true_lik\"]]$likelihood,\n                     color = \"orange\",\n                     alpha = 0.5) +\n          annotate(geom = \"text\",\n                   label = paste0(\"\\u03BC = \", input$theta),\n                   x = -Inf,\n                   y = Inf,\n                   hjust = 0,\n                   vjust = 1,\n                   color = \"orange\")\n        \n      }\n      \n      # add both the estimated MLE information and the theoretical (true) parameter information to the base likelihood plot\n      # -&gt; annotations were originally placed in different upper corners so they don't overlap\n      # -&gt; plotting both at the same time shows the differences between the estimated and true parameter value\n      # -&gt; this helps illustrate that we are estimating and getting close, but not exact\n      if(input$show_est == 1 & input$show_true == 1) {\n        \n        plot_lik_displayed &lt;- plot_lik +\n          geom_vline(xintercept = get_new_data()[[\"data_max_lik\"]]$theta_hat,\n                     color = \"blue\",\n                     alpha = 0.5) +\n          geom_hline(yintercept = get_new_data()[[\"data_max_lik\"]]$likelihood,\n                     color = \"blue\",\n                     alpha = 0.5) +\n          annotate(geom = \"text\",\n                   label = paste0(\"MLE ≈ \", round(get_new_data()[[\"data_max_lik\"]]$theta_hat, 3)),\n                   x = Inf,\n                   y = Inf,\n                   hjust = 1,\n                   vjust = 1,\n                   color = \"blue\") +\n          geom_vline(xintercept = input$theta,\n                     color = \"orange\",\n                     alpha = 0.5) +\n          geom_hline(yintercept = get_new_data()[[\"data_true_lik\"]]$likelihood,\n                     color = \"orange\",\n                     alpha = 0.5) +\n          annotate(geom = \"text\",\n                   label = paste0(\"\\u03BC = \", input$theta),\n                   x = -Inf,\n                   y = Inf,\n                   hjust = 0,\n                   vjust = 1,\n                   color = \"orange\")\n        \n      }\n      \n      # strategy for getting fancy labels in ggplot\n      # -&gt; resource for getting greek letters in labels for ggplot with expression()-&gt; https://stackoverflow.com/questions/5293715/how-to-use-greek-symbols-in-ggplot2\n      # -&gt; also using unicode occasionally when needing to combine a value with a greek letter\n      # -&gt; or putting fancy symbols directly in here if possible\n      # -&gt; so really no strategy, just piecemealing it to do what is needed\n      \n      # create base plot of log likelihood function\n      # -&gt; all features / interpretations / rationale is the same as for the likelihood plot, except now for the loglik\n      # -&gt; same for the additional plots as well\n      # log likelihood function will have same shape and same name nature / location of the extrema, which demonstrates that maximizing this and the regular likelihood function is equivalent\n      plot_loglik &lt;- ggplot() +\n        geom_line(aes(x = theta_hat,\n                      y = loglik,\n                      color = \"Log Likelihood Function\"),\n                  data = get_new_data()[[\"data_mle\"]]) +\n        scale_fill_manual(values = \"white\") +\n        scale_color_manual(values = \"grey30\") +\n        labs(x = expression(hat(mu)),\n             y = expression(\"\\u2113(\"~mu~\")\"),\n             color = \"\",\n             fill = \"\") +\n        theme(legend.position = \"bottom\")\n      \n      # set initial plot to be displayed\n      plot_loglik_displayed &lt;- plot_loglik\n      \n      # add estimated MLE information to the base log-likelihood plot\n      if(input$show_est == 1 & input$show_true == 0) {\n        \n        plot_loglik_displayed &lt;- plot_loglik +\n          geom_vline(xintercept = get_new_data()[[\"data_max_lik\"]]$theta_hat,\n                     color = \"blue\",\n                     alpha = 0.5) +\n          geom_hline(yintercept = get_new_data()[[\"data_max_lik\"]]$loglik,\n                     color = \"blue\",\n                     alpha = 0.5) +\n          annotate(geom = \"text\",\n                   label = paste0(\"MLE ≈ \", round(get_new_data()[[\"data_max_lik\"]]$theta_hat, 3)),\n                   x = Inf,\n                   y = Inf,\n                   hjust = 1,\n                   vjust = 1,\n                   color = \"blue\")\n        \n      }\n      \n      # add theoretical (true) parameter information to the base log-likelihood plot\n      if(input$show_est == 0 & input$show_true == 1) {\n        \n        plot_loglik_displayed &lt;- plot_loglik +\n          geom_vline(xintercept = input$theta,\n                     color = \"orange\",\n                     alpha = 0.5) +\n          geom_hline(yintercept = get_new_data()[[\"data_true_lik\"]]$loglik,\n                     color = \"orange\",\n                     alpha = 0.5) +\n          annotate(geom = \"text\",\n                   label = paste0(\"\\u03BC = \", input$theta),\n                   x = -Inf,\n                   y = Inf,\n                   hjust = 0,\n                   vjust = 1,\n                   color = \"orange\")\n        \n      }\n      \n      # add both the estimated MLE information and the theoretical (true) parameter information to the base log-likelihood plot\n      # -&gt; vertical difference between the estimated and true functional values will be less because the scale changed with the log-transformation\n      if(input$show_est == 1 & input$show_true == 1) {\n        \n        plot_loglik_displayed &lt;- plot_loglik +\n          geom_vline(xintercept = get_new_data()[[\"data_max_lik\"]]$theta_hat,\n                     color = \"blue\",\n                     alpha = 0.5) +\n          geom_hline(yintercept = get_new_data()[[\"data_max_lik\"]]$loglik,\n                     color = \"blue\",\n                     alpha = 0.5) +\n          annotate(geom = \"text\",\n                   label = paste0(\"MLE ≈ \", round(get_new_data()[[\"data_max_lik\"]]$theta_hat, 3)),\n                   x = Inf,\n                   y = Inf,\n                   hjust = 1,\n                   vjust = 1,\n                   color = \"blue\") +\n          geom_vline(xintercept = input$theta,\n                     color = \"orange\",\n                     alpha = 0.5) +\n          geom_hline(yintercept = get_new_data()[[\"data_true_lik\"]]$loglik,\n                     color = \"orange\",\n                     alpha = 0.5) +\n          annotate(geom = \"text\",\n                   label = paste0(\"\\u03BC = \", input$theta),\n                   x = -Inf,\n                   y = Inf,\n                   hjust = 0,\n                   vjust = 1,\n                   color = \"orange\")\n        \n      }\n      \n      # final plots to display plots\n      # -&gt; these objects have been conditionally updated based on the checkboxes\n      ggarrange(plot_lik_displayed, plot_loglik_displayed)\n      \n    }) # isolate\n  }) # render plot\n  \n  ## ---- Plot of derivative of loglik and second derivative of loglik ----\n  \n  # render plots of derivative of loglik and second derivative of loglik after generating new data\n  output$plot_derivatives &lt;- renderPlot({\n    \n    # take a dependency on action button\n    # -&gt; and prevent it from returning a plot the first time (ie don't run code until action button is hit)\n    if (input$run == 0) {return()}\n    \n    # use isolate to avoid dependency on action button\n    isolate({\n      \n      # error check for invalid standard deviation value\n      if (input$run != 0 & input$sigma &lt;= 0) {\n        \n        # create an empty plot essentially that contains the desired error message\n        g &lt;- ggplot() + \n          annotate(geom = \"text\",\n                   label = \"Please enter a value for σ greater than zero!\",\n                   color = \"red\",\n                   x = 1,\n                   y = 1) +\n          theme_void()\n        \n        # return plot\n        return(g)\n        \n      }\n      \n      # create base plot of the first derivative of log likelihood function\n      # line represent the functional values for the first derivative across the theta_hat values\n      # adding horizontal reference line at y = 0 because that is what we are looking for when analyzing the first derivative\n      # -&gt; specifcally the theta_hat value when that first derivative equals zero\n      # -&gt; dashed and transparentish so because it's just for reference and not a focal point\n      # other features of this plot are the same as all the others\n      plot_d_loglik &lt;- ggplot() + \n        geom_line(aes(x = theta_hat,\n                      y = d_loglik,\n                      color = \"Derivative of Loglik Function\"),\n                  data =get_new_data()[[\"data_mle\"]]) + \n        geom_hline(yintercept = 0,\n                   color = \"plum\",\n                   linetype = \"dashed\",\n                   alpha = 0.5) + \n        scale_fill_manual(values = \"white\") + \n        scale_color_manual(values = \"grey30\") + \n        labs(x = expression(hat(mu)),\n             y = expression(delta~\"[\\u2113(\"~mu~\")]\"),\n             color = \"\",\n             fill = \"\") + \n        theme(legend.position = \"bottom\")\n      \n      # set initial plot to be displayed\n      plot_d_loglik_display &lt;- plot_d_loglik\n      \n      # add estimated MLE information to the base first derivative of the log-likelihood plot\n      # -&gt; same vertical line and annotation as for the likelihood plots\n      # -&gt; this line crosses the derivative curve at y = 0, which is the reference line\n      # -&gt; this shows that at that theta_hat value, there is an extrema of some kind\n      # --&gt; so this is when we solve for the candidate MLE\n      if(input$show_est == 1) {\n        \n        plot_d_loglik_display &lt;- plot_d_loglik + \n          geom_vline(xintercept = get_new_data()[[\"data_max_lik\"]]$theta_hat,\n                     color = \"blue\",\n                     alpha = 0.5) + \n          annotate(geom = \"text\",\n                   label = paste0(\"MLE ≈ \", round(get_new_data()[[\"data_max_lik\"]]$theta_hat, 3)),\n                   x = Inf,\n                   y = Inf,\n                   hjust = 1,\n                   vjust = 1,\n                   color = \"blue\")\n        \n      }\n      \n      # not showing the theoretical value info cause not really relevant for this plot I think\n      \n      # create plot of second derivative of the loglik function\n      # line represent the functional values for the second derivative at across the theta_hat values\n      # just connecting the dots for a smooth curve\n      # adding horizontal reference line at y = 0 because that is what we are comparing to when analyzing the second derivative\n      # -&gt; if the second derivative is less than zero, that tells us the loglik function is concave down\n      # --&gt; so it is indeed a global max\n      plot_d2_loglik &lt;- ggplot() + \n        geom_line(aes(x = theta_hat,\n                      y = d2_loglik,\n                      color = \"Second Derivative of Loglik Function\"),\n                  data = get_new_data()[[\"data_mle\"]]) + \n        geom_hline(yintercept = 0,\n                   color = \"plum\",\n                   linetype = \"dashed\",\n                   alpha = 0.5) + \n        scale_fill_manual(values = \"white\") + \n        scale_color_manual(values = \"grey30\") + \n        labs(x = expression(hat(mu)),\n             y = expression(delta^2~\"[\\u2113(\"~mu~\")]\"),\n             color = \"\",\n             fill = \"\") + \n        theme(legend.position = \"bottom\")\n      \n      # not showing any MLE information\n      # -&gt; I feel like the second derivative shouldn't be a function of the parameter anymore, so it makes sense that it's constant\n      # --&gt; but not totally sure on this....?\n      \n      # display plots\n      # -&gt; only ever one plot for the second derivative, so didn't need to rename to a display one\n      ggarrange(plot_d_loglik_display, plot_d2_loglik)\n      \n    }) # isolate\n  }) # render plot\n  \n} # server\n\nCombine\n\n### ---- Run app ---- \n\nshinyApp(ui, server)",
    "crumbs": [
      "Interview"
    ]
  },
  {
    "objectID": "totalcare.html",
    "href": "totalcare.html",
    "title": "TotalCare analysis",
    "section": "",
    "text": "Dashboard",
    "crumbs": [
      "TotalCare analysis"
    ]
  },
  {
    "objectID": "totalcare.html#code",
    "href": "totalcare.html#code",
    "title": "TotalCare analysis",
    "section": "Code",
    "text": "Code\nPre code\n\n### ----- Load packages ---- \n\nlibrary(shiny)\nlibrary(gridlayout)\nlibrary(bslib)\nlibrary(tidyverse)\nlibrary(plotly)\n\n### ---- Functions ---- \n\n# create function to load data\nload_data &lt;- function(path, tab = 1) {\n  \n  readxl::read_excel(path, sheet = tab) %&gt;% \n    mutate(date = mdy(date))\n\n}\n\n# create function to aggregate data\naggregate_data &lt;- function(data, aggregate) {\n  \n  # standardize data\n  # -&gt; so response variable is always called the same thing\n  data_standard=data %&gt;% \n    rename(y = 2)\n  \n  # aggregate data based on different time frames\n  data_agg = if (identical(aggregate, \"daily\")) {\n    \n    data_standard\n    \n  } else if (identical(aggregate, \"weekly\")){\n    \n    data_standard %&gt;% \n      group_by(year(date), week(date)) %&gt;% \n      summarize(date = max(date),\n                y = sum(y)) %&gt;% \n      ungroup %&gt;% \n      select(date, y)\n    \n  }else if (identical(aggregate, \"monthly\")){\n    \n    data_standard %&gt;% \n      group_by(year(date), month(date)) %&gt;% \n      summarize(date = max(date),\n                y = sum(y)) %&gt;% \n      ungroup %&gt;% \n      select(date, y)\n    \n  }else if (identical(aggregate, \"quarterly\")){\n    \n    data_standard %&gt;% \n      group_by(year(date), quarter(date)) %&gt;% \n      summarize(date = max(date),\n                y = sum(y)) %&gt;% \n      ungroup %&gt;% \n      select(date, y)\n    \n  }else{\n    \n    data_standard %&gt;% \n      group_by(year(date)) %&gt;% \n      summarize(date = max(date),\n                y = sum(y)) %&gt;% \n      ungroup %&gt;% \n      select(date, y)\n    \n  }\n  \n  return(data_agg)\n}\n\n# create function to plot data\nplot_data &lt;- function(data, var, aggregate, n) {\n  \n  # create base plotly\n  # -&gt; calculate MA first\n  y_ma = data$y %&gt;% forecast::ma(order = n)\n  p = data %&gt;% \n    plot_ly() %&gt;% \n    add_lines(x = ~date,\n              y = ~y,\n              text = ~paste0(date, \"\\n\", ifelse(var %in% c(\"office_visits\", \"new_patients\"), \"\", \"$\"), scales::comma(y)), \n              color = I(\"grey70\"),\n              name = ~paste0(aggregate, \" data\")) %&gt;% \n    add_lines(x = ~date,\n              y = y_ma,\n              text = ~paste0(n, \" period MA: \", ifelse(var %in% c(\"office_visits\", \"new_patients\"), \"\", \"$\"), scales::comma(as.numeric(y_ma))),\n              color = I(\"blue\"),\n              name = paste0(n, \" period MA\"))\n  \n  # conditionally add axis title and main title\n  if (identical(var, \"charges\")) {\n    \n    p = p %&gt;% \n      layout(title = \"Charges\",\n             yaxis = list(title = \"dollars\"))\n    \n  } else if (identical(var, \"collections\")) {\n    \n    p = p %&gt;% \n      layout(title = \"Collections\",\n             yaxis = list(title = \"dollars\"))\n    \n  } else if (identical(var, \"new_patients\")) {\n    \n    p = p %&gt;% \n      layout(title = \"New Patients\",\n             yaxis = list(title = \"patients\"))\n    \n  } else if (identical(var, \"office_visits\")) {\n    \n    p = p %&gt;% \n      layout(title = \"Office Visits\",\n             yaxis = list(title = \"visitors\"))\n    \n  } else if (identical(var, \"shockwave\")) {\n    \n    p = p %&gt;% \n      layout(title = \"Shockwave\",\n             yaxis = list(title = \"dollars\"))\n    \n  } else if (identical(var, \"weight_loss\")) {\n    \n    p = p %&gt;% \n      layout(title = \"Weight Loss\",\n             yaxis = list(title = \"dollars\"))\n    \n  } else {\n    \n    p = p %&gt;% \n      layout(title = \"Shockwave + Weightloss\",\n             yaxis = list(title = \"dollars\"))\n    \n  }\n  \n  return(p)\n  \n}\n\nUI\n\n### ---- Define UI ---- \n\nui &lt;- grid_page(\n  layout = c(\n    \"header header\",\n    \"sidebar  plot\"\n  ),\n  row_sizes = c(\n    \"100px\",\n    \"1fr\"\n  ),\n  col_sizes = c(\n    \"250px\",\n    \"1fr\"\n  ),\n  gap_size = \"1rem\",\n  grid_card_text(\n    area = \"header\",\n    content = \"TotalCare Analysis!\",\n    alignment = \"start\",\n    is_title = FALSE\n  ),\n  grid_card(\n    area = \"sidebar\",\n    card_body(\n      card(\n        full_screen = TRUE,\n        card_header(\"Load Data\"),\n        card_body(\n          fileInput(inputId = \"target_upload\",\n                    label = \"Select excel file\",\n                    accept = \".xlsx\")\n        )\n      ),\n      card(\n        full_screen = TRUE,\n        card_header(\"Settings\"),\n        card_body(\n          selectInput(\n            inputId = \"var\",\n            label = \"Select Variable\",\n            choices = list(\n              \"Charges\" = \"charges\",\n              \"Collections\" = \"collections\",\n              \"New Patients\" = \"new_patients\",\n              \"Office Visits\" = \"office_visits\",\n              \"Shockwave\" = \"shockwave\",\n              \"Weight Loss\" = \"weight_loss\",\n              \"Shockwave + Weight Loss\" = \"shockwave_and_weight_loss\"\n            )\n          ),\n          radioButtons(\n            inputId = \"aggregate\",\n            label = \"Aggregate\",\n            choices = list(\n              \"Daily\" = \"daily\",\n              \"Weekly\" = \"weekly\",\n              \"Monthly\" = \"monthly\",\n              \"Quarterly\" = \"quarterly\",\n              \"Yearly\" = \"yearly\"\n            ),\n            width = \"100%\"\n          ),\n          sliderInput(\n            inputId = \"n\",\n            label = \"N Period Moving Average\",\n            min = 2,\n            max = 30,\n            value = 5,\n            width = \"100%\",\n            step = 1\n          )\n        )\n      )\n    )\n  ),\n  grid_card(\n    area = \"plot\",\n    card_header(\"Interactive Plot\"),\n    card_body(\n      plotlyOutput(\n        outputId = \"plot\",\n        width = \"100%\",\n        height = \"100%\"\n      )\n    )\n  )\n)\n\nServer\n\n### ---- Define server ---- \n\nserver &lt;- function(input, output) {\n  \n  data_all &lt;- reactive({\n    \n    # read in file\n    # -&gt; skip running below code before a file is loaded\n    file = input$target_upload\n    req(file)\n    \n    # load all data\n    tabs = c(\"charges\", \"collections\", \"new_patients\", \"office_visits\", \"shockwave\", \"weight_loss\")\n    data_tmp = tabs %&gt;% map(\\(tab) load_data(file$datapath, tab = tab))\n    names(data_tmp) = tabs\n    \n    # combine shockwave and weight loss data\n    data_tmp$shockwave_and_weight_loss = data_tmp$shockwave %&gt;%\n      full_join(data_tmp$weight_loss, by = join_by(date)) %&gt;%\n      mutate(shockwave_and_weight_loss = shockwave + weight_loss) %&gt;%\n      arrange(date) %&gt;%\n      select(date, shockwave_and_weight_loss)\n    \n    return(data_tmp)\n    \n  })\n  \n  \n  output$plot &lt;- renderPlotly({\n  \n    data_all()[[input$var]] %&gt;%\n      aggregate_data(aggregate = input$aggregate) %&gt;%\n      plot_data(var = input$var, aggregate = input$aggregate, n = input$n)\n    \n  })\n\n}\n\nCombine\n\n### ---- Run app ---- \n\nshinyApp(ui, server)",
    "crumbs": [
      "TotalCare analysis"
    ]
  },
  {
    "objectID": "measuring.html",
    "href": "measuring.html",
    "title": "Measuring",
    "section": "",
    "text": "Dashboard",
    "crumbs": [
      "Measuring"
    ]
  },
  {
    "objectID": "measuring.html#code",
    "href": "measuring.html#code",
    "title": "Measuring",
    "section": "Code",
    "text": "Code\nPre code\n\n### ----- Load packages ---- \n\nlibrary(shiny)\nlibrary(gridlayout)\nlibrary(bslib)\nlibrary(tidyverse)\nlibrary(plotly)\n\n# NOTE: THINGS TO ADD\n# -&gt; add beginning date as filter to all plots\n\n### ---- Functions ---- \n\n# create function to aggregate data\naggregate_data &lt;- function(data, var, aggregate) {\n  \n  # conditionally check if need to aggregate based on selected variable\n  if (var %in% c(\"out_of_bed_time\",\"bed_time\")) {\n    \n    return(data)\n    \n  }\n  \n  else {\n    \n    # aggregate data based on different time frames\n    data_agg = if (identical(aggregate, \"daily\")) {\n      \n      data\n      \n    } else if (identical(aggregate, \"weekly\")){\n      \n      data %&gt;% \n        group_by(year(date), week(date)) %&gt;% \n        summarize(date = max(date),\n                  across(c(snooze_time,work_hours,study_hours,movement_time), \\(var) sum(var, na.rm = TRUE))) %&gt;% \n        ungroup %&gt;% \n        #mutate(across(c(snooze_time,work_hours,study_hours,movement_time)), \\(var) if_else(var == 0, NA, var)) DOESN'T WORK, figure out how to make better later\n        mutate(snooze_time = ifelse(snooze_time == 0, NA, snooze_time),\n               work_hours = ifelse(work_hours == 0, NA, work_hours),\n               study_hours = ifelse(study_hours == 0, NA, study_hours),\n               movement_time = ifelse(movement_time == 0, NA, movement_time))\n      \n    }else{ # monthly\n      \n      data %&gt;% \n        group_by(year(date), month(date)) %&gt;% \n        summarize(date = max(date),\n                  across(c(snooze_time,work_hours,study_hours,movement_time), \\(var) sum(var, na.rm = TRUE))) %&gt;% \n        ungroup %&gt;% \n        mutate(snooze_time = ifelse(snooze_time == 0, NA, snooze_time),\n               work_hours = ifelse(work_hours == 0, NA, work_hours),\n               study_hours = ifelse(study_hours == 0, NA, study_hours),\n               movement_time = ifelse(movement_time == 0, NA, movement_time))\n    }\n    \n    return(data_agg)\n    \n  }\n  \n}\n\n\n# create function to plot data\nplot_data &lt;- function(data, var, aggregate, smooth) {\n  \n  # conditionally create base ggplot objects\n  # -&gt; creating line plots with correct titles\n  # -&gt; adding correct reference lines too\n  if (identical(var, \"out_of_bed_time\")) {\n    \n    g = data %&gt;% \n      ggplot(aes(x = date,\n                 y = out_of_bed_time,\n                 group = 1)) + \n      geom_point(col = \"grey50\") + \n      geom_line(col = \"grey50\") + \n      geom_hline(yintercept = ymd_hms(\"2024/01/01 8:00:00\") %&gt;% as.numeric, # extra step needed for ggplotly\n                 col = \"darkgreen\") + \n      scale_y_datetime(date_labels = (\"%I %p\")) + \n      labs(title= \"Out of bed time\",\n           x = \"Date\",\n           y = \"Time\")\n    \n  } else if (identical(var, \"bed_time\")) {\n    \n    g = data %&gt;% \n      ggplot(aes(x = date,\n                 y = bed_time,\n                 group = 1)) + \n      geom_point(col = \"grey50\") + \n      geom_line(col = \"grey50\") + \n      geom_hline(yintercept = ymd_hms(\"2024/01/01 23:00:00\") %&gt;% as.numeric, # extra step needed for ggplotly\n                 col = \"darkgreen\") + \n      scale_y_datetime(date_labels = (\"%I %p\")) + \n      labs(title = \"Bed time\",\n           x = \"Date\",\n           y = \"Time\")\n    \n  } else if (identical(var, \"snooze_time\")) {\n    \n    g = data %&gt;% \n      ggplot(aes(x = date,\n                 y = snooze_time,\n                 group = 1)) + \n      geom_point(col = \"grey50\") + \n      geom_line(col = \"grey50\") + \n      geom_hline(yintercept = case_when(identical(aggregate, \"daily\") ~ 30,\n                                         identical(aggregate, \"weekly\") ~ 210,\n                                         .default = NA),\n                 col = \"darkgreen\") + \n      labs(title = \"Snooze time\",\n           x = \"Date\",\n           y = \"Minutes\")\n    \n  } else if (identical(var, \"work_hours\")) {\n    \n    g = data %&gt;% \n      ggplot(aes(x = date,\n                 y = work_hours,\n                 group = 1)) + \n      geom_point(col = \"grey50\") + \n      geom_line(col = \"grey50\") + \n      geom_hline(yintercept = case_when(identical(aggregate, \"daily\") ~ 8,\n                                        identical(aggregate, \"weekly\") ~ 40,\n                                        .default = NA),\n                 col = \"darkgreen\") + \n      labs(title = \"Work hours\",\n           x = \"Date\",\n           y = \"Hours\")\n    \n  } else if (identical(var, \"study_hours\")) {\n    \n    g = data %&gt;% \n      ggplot(aes(x = date,\n                 y = study_hours,\n                 group = 1)) + \n      geom_point(col = \"grey50\") + \n      geom_line(col = \"grey50\") + \n      geom_hline(yintercept = case_when(identical(aggregate, \"daily\") ~ 2.5,\n                                        identical(aggregate, \"weekly\") ~ 17.5,\n                                        .default = NA),\n                 col = \"darkgreen\") + \n      labs(title = \"Study hours\",\n           x = \"Date\",\n           y = \"Hours\")\n    \n  }else { # movement_time\n    \n    g = data %&gt;% \n      ggplot(aes(x = date,\n                 y = movement_time,\n                 group = 1)) + \n      geom_point(col = \"grey50\") + \n      geom_line(col = \"grey50\") + \n      geom_hline(yintercept = case_when(identical(aggregate, \"daily\") ~ 60,\n                                        identical(aggregate, \"weekly\") ~ 420,\n                                        .default = NA),                 \n                 col = \"darkgreen\") + \n      labs(title = \"Movement time\",\n           x = \"Date\",\n           y = \"Minutes\")\n    \n  }\n  \n  # conditionally add smooth curve\n  if(identical(smooth, TRUE)) {\n    \n    g = g + \n      geom_smooth()\n  }\n  \n  g = g + theme_bw()\n  \n  ggplotly(g) %&gt;% return()\n  \n}\n\nUI\n\n### ---- Define UI ---- \n\n# read and format data\ndata_measuring &lt;- readxl::read_excel(\"measuring.xlsx\") %&gt;% \n  select(-c(8:14)) %&gt;% # remove extra columns from study goal tracker\n  mutate(date = mdy(date),\n         out_of_bed_time = str_c('2024-01-01', out_of_bed_time, sep = ' ') %&gt;% ymd_hm, # set to constant day (only to plot the time info)\n         bed_time = str_c('2024-01-01', bed_time, sep = ' ') %&gt;% ymd_hm, # set to constant day (only to plot the time info)\n         across(c(snooze_time, work_sessions, movement_time), as.numeric),\n         work_hours = work_sessions * 2) %&gt;% # convert to hours and change variable\n  select(1:4,8,6:7) %&gt;% # reorder and select desired columns\n  filter(date &lt;= Sys.Date()) # filter to non-future rows\n\nui &lt;- grid_page(\n  layout = c(\n    \"header header\",\n    \"sidebar  plot\"\n  ),\n  row_sizes = c(\n    \"100px\",\n    \"1fr\"\n  ),\n  col_sizes = c(\n    \"250px\",\n    \"1fr\"\n  ),\n  gap_size = \"1rem\",\n  grid_card_text(\n    area = \"header\",\n    content = \"Measuring!\",\n    alignment = \"start\",\n    is_title = FALSE\n  ),\n  grid_card(\n    area = \"sidebar\",\n    card_body(\n      card(\n        full_screen = TRUE,\n        card_header(\"Settings\"),\n        card_body(\n          selectInput(\n            inputId = \"var\",\n            label = \"Select Variable\",\n            choices = list(\n              \"Out of bed time\" = \"out_of_bed_time\",\n              \"Snooze time\" = \"snooze_time\",\n              \"Bed time\" = \"bed_time\",\n              \"Work hours\" = \"work_hours\",\n              \"Study hours\" = \"study_hours\",\n              \"Movement time\" = \"movement time\"\n            )\n          ),\n          radioButtons(\n            inputId = \"aggregate\",\n            label = \"Aggregate\",\n            choices = list(\n              \"Daily\" = \"daily\",\n              \"Weekly\" = \"weekly\",\n              \"Monthly\" = \"monthly\"\n            ),\n            width = \"100%\"\n          ),\n          checkboxInput(\n            inputId = \"smooth\",\n            label = \"Add smooth curve\",\n            value = FALSE,\n            width = \"100%\"\n          )\n        )\n      )\n    )\n  ),\n  grid_card(\n    area = \"plot\",\n    card_header(\"Interactive Plot\"),\n    card_body(\n      plotlyOutput(\n        outputId = \"plot\",\n        width = \"100%\",\n        height = \"100%\"\n      )\n    )\n  )\n)\n\nServer\n\n### ---- Define server ---- \n\nserver &lt;- function(input, output) {\n  \n  \n  output$plot &lt;- renderPlotly({\n  \n    # aggregate data and create plot\n    data_measuring %&gt;% \n      aggregate_data(var = input$var, aggregate = input$aggregate) %&gt;% \n      plot_data(var = input$var, aggregate = input$aggregate, smooth = input$smooth)\n    \n  })\n\n}\n\nCombine\n\n### ---- Run app ---- \n\nshinyApp(ui, server)",
    "crumbs": [
      "Measuring"
    ]
  }
]